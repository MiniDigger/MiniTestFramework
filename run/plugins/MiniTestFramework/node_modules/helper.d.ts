export const EntityType: EntityTypeDelegate
export class EntityTypeDelegate {
  public static AREA_EFFECT_CLOUD: any;
  public static ARMOR_STAND: any;
  public static ARROW: any;
  public static AXOLOTL: any;
  public static BAT: any;
  public static BEE: any;
  public static BLAZE: any;
  public static BOAT: any;
  public static CAT: any;
  public static CAVE_SPIDER: any;
  public static CHICKEN: any;
  public static COD: any;
  public static COW: any;
  public static CREEPER: any;
  public static DOLPHIN: any;
  public static DONKEY: any;
  public static DRAGON_FIREBALL: any;
  public static DROWNED: any;
  public static ELDER_GUARDIAN: any;
  public static END_CRYSTAL: any;
  public static ENDER_DRAGON: any;
  public static ENDERMAN: any;
  public static ENDERMITE: any;
  public static EVOKER: any;
  public static EVOKER_FANGS: any;
  public static EXPERIENCE_ORB: any;
  public static EYE_OF_ENDER: any;
  public static FALLING_BLOCK: any;
  public static FIREWORK_ROCKET: any;
  public static FOX: any;
  public static GHAST: any;
  public static GIANT: any;
  public static GLOW_ITEM_FRAME: any;
  public static GLOW_SQUID: any;
  public static GOAT: any;
  public static GUARDIAN: any;
  public static HOGLIN: any;
  public static HORSE: any;
  public static HUSK: any;
  public static ILLUSIONER: any;
  public static IRON_GOLEM: any;
  public static ITEM: any;
  public static ITEM_FRAME: any;
  public static FIREBALL: any;
  public static LEASH_KNOT: any;
  public static LIGHTNING_BOLT: any;
  public static LLAMA: any;
  public static LLAMA_SPIT: any;
  public static MAGMA_CUBE: any;
  public static MARKER: any;
  public static MINECART: any;
  public static CHEST_MINECART: any;
  public static COMMAND_BLOCK_MINECART: any;
  public static FURNACE_MINECART: any;
  public static HOPPER_MINECART: any;
  public static SPAWNER_MINECART: any;
  public static TNT_MINECART: any;
  public static MULE: any;
  public static MOOSHROOM: any;
  public static OCELOT: any;
  public static PAINTING: any;
  public static PANDA: any;
  public static PARROT: any;
  public static PHANTOM: any;
  public static PIG: any;
  public static PIGLIN: any;
  public static PIGLIN_BRUTE: any;
  public static PILLAGER: any;
  public static POLAR_BEAR: any;
  public static TNT: any;
  public static PUFFERFISH: any;
  public static RABBIT: any;
  public static RAVAGER: any;
  public static SALMON: any;
  public static SHEEP: any;
  public static SHULKER: any;
  public static SHULKER_BULLET: any;
  public static SILVERFISH: any;
  public static SKELETON: any;
  public static SKELETON_HORSE: any;
  public static SLIME: any;
  public static SMALL_FIREBALL: any;
  public static SNOW_GOLEM: any;
  public static SNOWBALL: any;
  public static SPECTRAL_ARROW: any;
  public static SPIDER: any;
  public static SQUID: any;
  public static STRAY: any;
  public static STRIDER: any;
  public static EGG: any;
  public static ENDER_PEARL: any;
  public static EXPERIENCE_BOTTLE: any;
  public static POTION: any;
  public static TRIDENT: any;
  public static TRADER_LLAMA: any;
  public static TROPICAL_FISH: any;
  public static TURTLE: any;
  public static VEX: any;
  public static VILLAGER: any;
  public static VINDICATOR: any;
  public static WANDERING_TRADER: any;
  public static WITCH: any;
  public static WITHER: any;
  public static WITHER_SKELETON: any;
  public static WITHER_SKULL: any;
  public static WOLF: any;
  public static ZOGLIN: any;
  public static ZOMBIE: any;
  public static ZOMBIE_HORSE: any;
  public static ZOMBIE_VILLAGER: any;
  public static ZOMBIFIED_PIGLIN: any;
  public static PLAYER: any;
  public static FISHING_BOBBER: any;
}
export const helper: GameTestHelper
export class GameTestHelper {
  fail(message: string);
  fail(message: string,pos);
  fail(message: string,entity);
  getLevel();
  killAllEntities();
  getBlockState(pos);
  spawnItem(item,x: number,y: number,z: number);
  absoluteVec(pos);
  getBlockEntity(pos);
  absolutePos(pos);
  spawn(type,pos);
  spawn(type,pos);
  spawn(type,x: number,y: number,z: number);
  spawn(type,x: number,y: number,z: number);
  assertEntityPresent(type,x: number,y: number,z: number);
  assertEntityPresent(type);
  assertEntityPresent(type,pos,radius: number);
  assertEntityPresent(type,pos);
  assertEntityInstancePresent(entity,x: number,y: number,z: number);
  assertEntityInstancePresent(entity,pos);
  assertItemEntityCountIs(item,pos,radius: number,amount: number);
  assertBlockNotPresent(block,pos);
  assertBlockNotPresent(block,x: number,y: number,z: number);
  assertBlockProperty(pos,property,value);
  assertBlockProperty(pos,property,predicate,errorMessage: string);
  assertItemEntityPresent(item,pos,radius: number);
  succeedWhenBlockPresent(block,pos);
  succeedWhenBlockPresent(block,x: number,y: number,z: number);
  spawnWithNoFreeWill(type,pos);
  spawnWithNoFreeWill(type,x: number,y: number,z: number);
  spawnWithNoFreeWill(type,x: number,y: number,z: number);
  spawnWithNoFreeWill(type,pos);
  assertEntityTouching(type,x: number,y: number,z: number);
  assertAtTickTimeContainerContains(l: number,blockPos,item);
  succeedWhenEntityPresent(type,pos);
  succeedWhenEntityPresent(type,x: number,y: number,z: number);
  assertEntityNotPresent(type);
  assertEntityNotPresent(type,pos);
  assertEntityNotPresent(type,x: number,y: number,z: number);
  assertContainerEmpty(pos);
  assertEntityProperty(entity,functionP,string: string,objectP);
  assertEntityProperty(entity,predicate,string: string);
  succeedWhenEntityData(blockPos,entityType,functionP,objectP);
  assertSameBlockState(checkedPos,correctStatePos);
  assertContainerContains(pos,item);
  assertSameBlockStates(checkedBlockBox,correctStatePos);
  forEveryBlockInStructure(consumer);
  succeedWhenEntityNotPresent(type,pos);
  succeedWhenEntityNotPresent(type,x: number,y: number,z: number);
  assertEntityNotTouching(type,x: number,y: number,z: number);
  assertAtTickTimeContainerEmpty(l: number,blockPos);
  startSequence();
  pressButton(x: number,y: number,z: number);
  pressButton(pos);
  walkTo(entity,pos,f: number);
  assertBlockState(pos,predicate,errorMessageSupplier);
  useBlock(pos);
  makeMockPlayer();
  setNight();
  destroyBlock(pos);
  setDayTime(timeOfDay: number);
  makeAboutToDrown(entity);
  pullLever(x: number,y: number,z: number);
  pullLever(pos);
  pulseRedstone(pos,delay: number);
  setBlock(pos,state);
  setBlock(pos,block);
  setBlock(x: number,y: number,z: number,state);
  setBlock(x: number,y: number,z: number,block);
  runAfterDelay(ticks: number,runnable);
  assertBlockPresent(block,pos);
  assertBlockPresent(block,x: number,y: number,z: number);
  succeedWhen(runnable);
  assertBlock(pos,predicate,errorMessage: string);
  assertBlock(pos,predicate,errorMessageSupplier);
  getTick();
  assertEntityData(pos,type,entityDataGetter,data);
  runAtTickTime(tick: number,runnable);
  succeed();
  succeedIf(runnable);
  randomTick(pos);
  onEachTick(runnable);
  relativePos(pos);
  succeedOnTickWhen(duration: number,runnable);
  failIfEver(runnable);
  failIf(runnable);
}
export const registry: MiniTestFramework
export class MiniTestFramework {
  register(batchId: string,name: string,tickLimit: number,duration: number,method: (helper: GameTestHelper) => void);
  register(batchId: string,name: string,method: (helper: GameTestHelper) => void);
  register(name: string,method: (helper: GameTestHelper) => void);
  register(batchId: string,name: string,rotation,tickLimit: number,duration: number,required: boolean,method: (helper: GameTestHelper) => void);
  register(batchId: string,name: string,rotation,tickLimit: number,duration: number,required: boolean,requiredSuccesses: number,maxAttempts: number,method: (helper: GameTestHelper) => void);
  onLoad();
  onCommand(sender,command,label: string,args);
}
